---
layout: post
title: "Kubernetes_12"
date: 2023-01-05
last_modified_at: 2023-01-05
categories: [Kubernetes]
tags: [Kubernetes]
---

# Service Cluster IP

 full stack 웹 애플리케이션은 일반적으로 애플리케이션의 다른 부분을 호스팅하는 다른 종류의 pod를 갖고 있다.   
 프론트엔드 웹 서버를 실행하는 여러 pod, 백엔드 서버를 실행하는 다른 pod, Redis와 같은 key-value 스토리지를 수행하는 pod,   
 MySQL고 같은 영구 데이터베이스를 실행하는 pod가 있을 수 있다.   
 웹 프론트엔드 서버는 백엔드 서버와 통신해야 하며, 백엔드 서버는 데이터베이스 및 Redis 서비스와 통신해야 한다.   
 
그렇다면 애플리케이션에 이러한 서비스 또는 계층 간 연결을 설정하는 올바른 방법은 무엇일까?   

모든 pod에는 IP 주소가 할당되어 있지만, 이러한 IP는 고정된 것이 아니다.   
pod는 언제든 동작이 중지될 수 있으며, 항상 새로운 pod가 생성되므로, 애플리케이션 간 내부 통신에 이러한 IP 주소를 사용할 수 없다.   

이러한 예제가 있다고 가정하자.    
<img width="582" alt="스크린샷 2023-01-05 오후 8 26 15" src="https://user-images.githubusercontent.com/83587720/210769614-91a5f759-2357-4886-99d8-604426f8be6f.png">

위 예제에서 10.244.0.3이라는 IP를 갖고 있는 프론트엔드 pod를 백엔드 서버에 연결하려면 어떻게 해야할까?   
세 개의 백엔드 pod 중 어느 쪽으로 연결되며 누가 그 결정을 내려야 할까?   

쿠버네티스 서비스는 pod를 그룹화하고 그룹 내 pod에 액세스 할 수 있는 단일 인터페이스를 제공하는 데 도움이 될 수 있다.   
예를 들어, 백엔드 pod 용으로 만들어진 서비스는 모든 백엔드 pod를 그룹화하고,    
다른 pod가 이 서비스에 액세스 할 수 있는 단일 인터페이스를 제공한다.   
요청은 무작위로 서비스 아래의 pod중 하나로 전달된다.    

마찬가지로 Redis에 대한 추가 서비스를 만들고, 백엔드 pod가 서비스를 통해 Redis 시스템에 액세스 할 수 있도록 허용한다.   
이를 통해 쿠버네티스 클러스터에 마이크로서비스 기반 애플리케이션을 쉽고 효과적으로 배포할 수 있다.   

이제 각 계층은 다양한 서비스 간의 통신에 영향을 미치지 않고 필요에 따라 확장하거나 이동할 수 있다.   
각 서비스는 클러스터 내에서 IP와 이름을 할당받고, 이 이름은 서비스에 접근하기 위해 다른 pod에서 사용한다.   
   
이러한 유형의 서비스를 Cluster IP라고 한다.   

Cluster IP를 생성하려면 항상 그렇듯, API 버전, 종류, 메타데이터 및 사양이 있는 기본 템플릿을 사용하여 서비스 정의 파일을 먼저 정의한다.    
```yml
apiVersion: v1
kind: Service
metadata:
    name: back-end

spec:
    type: ClusterIP
    ports:
     - targetPort: 80
       port: 80
```

API 버전은 v1, 종류는 서비스, 서비스 이름은 back-end이다.   
사양에는 타입과 포트가 있다.    
타입은 Cluster IP이다. 이는 기본 타입이므로 지정하지 않았더라도 자동으로 이 유형이 Cluster IP로 간주된다.   
포트 아래에는 타겟 포트와 포트가 있다. 타겟 포트는 백엔드가 노출되는 포트(이 경우에는 80)이며,   
포트는 서비스가 노출되는 포트(80)이다.   





