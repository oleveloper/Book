---
layout: post
title: "Kubernetes_01"
date: 2023-01-01
last_modified_at: 2023-01-01
categories: [Kubernetes]
tags: [Kubernetes]
---

# Core Concepts

## Cluster Architecture
쿠버네티스의 목적은 자동화된 방식을 통해 컨테이너 형태로 애플리케이션을 호스팅하여 여러 애플리케이션 인스턴스들을 쉽게 배포하고    
애플리케이션 내 서로 다른 서비스 간 쉽게 통신할 수 있도록 하는 것이다.

아래 글에서는 비유를 통해 쿠버네티스를 이해하도록 한다.

### Kubernetes Cluster
쿠버네티스에는 두 가지 종류의 배가 있다.

- 컨테이너를 나르는 화물선.  
  Kubernetes Cluster는 컨테이너 형태로 애플리케이션을 호스팅하는 물리적 또는 가상 노드의 set으로 구성된다.   
  클러스터의 worker node는 컨테이너를 적재할 수 있다.
- 화물선을 감시하고 관리하는 통제선.  
  컨테이너 적재 방법을 계획하고, 올바른 선박을 식별하고, 선박에 대한 정보를 저장하고, 선박의 컨테이너 위치를 모니터링하거나 추적하고, 전체 적재 과정을 관리하는 것이 통제선이다.   
  통제선은 쿠버네티스 클러스터의 마스터노드와 관련이 있다.

#### Master node
마스터 노드는 쿠버네티스 클러스터를 관리하고, 다른 노드에 대한 정보르 저장하며, 어떤 컨테이너가 어디로 가는지 계획하고, 노드와 컨테이너를 모니터링 하는 등의 작업을 수행한다.
마스터 노드는 Control playing components로 알려진 구성 요소들을 함께 사용하여 모든 작업을 수행한다.

아래에서 그 각각의 구성 요소를 살펴보기로 한다.

##### etcd Cluster
매일 많은 컨테이너들이 배에서 오르내리고 있기 때문에 다른 배들에 대한 정보 -어떤 컨테이너가 어떤 배에 있고 몇 시에 실렸는지 등-를 관리할 필요가 있다.
이 모든 정보들은 etcd라고 알려진 고가용성 key-value 저장소에 있다.
다른 편에서 etcd 클러스터가 실제로 무엇인지, 클러스터에 저장되는 데이터는 무엇인지, 데이터를 저장하는 방법은 어떻게 되는지 알아보도록 한다.

##### Scheduler
선박이 도착하면 크레인을 사용해 컨테이너를 적재한다. 크레인은 배에 놓아야 할 컨테이너를 식별한다.
크레인은 컨테이너의 크기나 용량, 이미 배에 선적되어 있는 컨테이너의 수, 배의 목적지, 배가 운반할 수 있는 컨테이너의 종류 등과 같은 다른 조건들에 기초해 적절한 배를 식별한다.
이것이 바로 스케줄러가 하는 일이다.
스케줄러는 컨테이너 리소스 요구사항, worker node의 용량, 정책 또는 제약 조건(taints, tolerations 또는 node affinity rule와 같은)에 따라 컨테이너를 배치 할 올바른 노드를 식별한다.

##### Controller Manager

부두에는 특수 업무에 할당된 사무실들이 있다.

- 운영팀   
  운영팀은 선박 처리나 교통 통제 등을 담당한다. 배들의 항해 경로 등의 피해와 관련된 문제를 담당한다.
- 화물팀   
  화물팀은 컨테이너를 관리한다. 컨테이너가 손상되거나 파괴되면 새로운 컨테이너를 사용할 수 있도록 한다.
- 서비스 오피스   
  다른 선박 간의 통신을 담당하는 서비스 오피스가 있다.

위와 같이 쿠버네티스에서는 다양한 영역을 관리하는 컨트롤러들을 사용할 수 있다.

노드 컨트롤러는 노드를 처리한다.   
노드 컨트롤러는 새로운 노드를 클러스터에 onboard하고, 노드를 사용할 수 없게 되거나 파괴되는 상황을 처리하며,   
레플리케이션 컨트롤러는 복제 그룹에서 원하는 수의 컨테이너가 항상 실행되도록 보장한다.

##### Kube API Server
위에서는 사무실, 배, 데이터 저장소, 크레인과 같은 구성 요소들을 설명했다.   
그런데 이 요소들은 서로 어떻게 소통할까?

Kube API 서버는 쿠버네티스의 기본 관리 구성 요소이다. Kube API 서버는 클러스터 내의 모든 작업들을 orchestrating한다.
외부 유저가 클러스터에서 매니지먼트 작업을 수행하는 데에 사용되는 쿠버네티스 API와 클러스터 상태를 모니터링하고 필요에 따라 변경을 수행하는 여러 가지 컨트롤러, 그리고 worker node가 서버와 통신하는 데 사용하는 다양한 컨트롤러를 노출한다.

##### Container
모든 것은 컨테이너와 호환되어야 한다. 우리의 애플리케이션은 컨테이너 형태이다.
마스터 노드의 전체 매니지먼트 시스템을 구성하는 다양한 구성 요소는 컨테이너의 형태로 호스팅 될 수 있다.

DNS 네트워킹 솔루션은 모두 컨테이너 형태로 배포할 수 있다. 그렇기 때문에 컨테이너를 실행할 수 있는 소프트웨어가 필요하다.    
그것이 바로 컨테이너 런타임 엔진이다. (대표적인 컨테이너 런타임 엔진으로는 Docker가 있다.)

컨테이너로 컨트롤 요소들을 호스팅하려면 Docker 또는 Docker와 같은 기능이 클러스터의 모든 노드에 설치되어 있어야 한다.   
쿠버네티스는 ContainerD, Rocker과 같은 다른 런타임 엔진을 지원한다.

##### Kubelet
모든 배에는 선장이 있다. 선장은 배의 모든 활동을 관리 할 책임이 있다.

선장은 그룹에 참여하는 데에 관심이 있다는 것을 mastership에게 알리는 것 부터 시작해서,    
선적할 컨테이너에 대한 정보를 받고, 필요에 따라 적절한 컨테이너를 적재하고, 배의 상태에 대한 보고서를 master에게 다시 보낸다.

배의 선장은 kubelet이다.

kubelet은 클러스터의 각 노드에서 실행되는 에이전트이다.    
kube API 서버의 지시를 수신하고 필요에 따라 노드의 컨테이너를 배포 또는 파괴한다.   
kube API 서버는 정기적으로 이 kubelet으로부터 상태 보고서를 가져와 노드와 컨테이너의 상태를 모니터링한다.

##### Kube Proxy Service
kubelet은 선박의 컨테이너를 관리하는 선장에 가깝지만, Worker 노드에서 실행되는 애플리케이션은 서로 통신할 수 있어야 한다.   
예를 들면 웹 서버가 하나의 노드 위의 컨테이너에서 실행되고, 데이터베이스 서버가 다른 노드의 컨테이너에서 실행될 수 있는 것이다.   

웹 서버가 다른 노드의 데이터베이스 서버에 어떻게 도달할 수 있을까?

Worker node 간의 통신은 Kube Proxy Service 로 알려진 Worker node에서 실행되는 다른 구성 요소에 의해 활성화된다.   
Kube proxy service는 Worker node에서 실행 중인 컨테이너가 서로 연결될 수 있도록 Worker node에 필요한 규칙을 적용한다.   
