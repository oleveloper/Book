---
layout: post
title: "Kubernetes_56 Storage in Docker"
date: 2023-01-20
last_modified_at: 2023-01-20
categories: [Kubernetes]
tags: [Kubernetes]
---

# Storage in Docker

이번에는 Docker 스토리지 드라이버와 파일 시스템에 대해 이야기하려고 한다.   
도커가 데이터를 어디에 어떻게 저장하고 컨테이너의 파일 시스템을 어떻게 관리하는지 알아보자.   
Docker가 로컬 파일 시스템에 데이터를 저장하는 방법부터 살펴보겠다.   
시스템에 Docker를 설치하면 /var/lib/docker/에 이 폴더 구조가 생성된다.   
여기에는 AUFS 컨테이너, 이미지 볼륨 등의 폴더가 여러 개 있다.   
<img width="212" alt="스크린샷 2023-01-20 오후 8 00 03" src="https://user-images.githubusercontent.com/83587720/213679748-360371ca-bf89-462e-b704-3b0849b36051.png">   
도커는 기본적으로 모든 데이터를 이 곳에 저장한다.   

데이터라고 하면 도커 호스트에서 실행되는 이미지 및 컨테이너와 관련된 파일을 의미한다.   
예를 들어, 컨테이너와 관련된 모든 파일은 컨테이너 폴더 아래에 저장되고 이미지와 관련된 파일은 이미지 폴더 아래에 저장된다.   
도커 컨테이너에서 생성된 모든 볼륨은 볼륨 폴더 아래에 생성된다.   
지금은 도커가 파일을 어디에 저장하고 어떤 형식으로 저장하는지만 알아보자.   

그렇다면 도커는 이미지와 컨테이너의 파일을 정확히 어떻게 저장할까?   
Docker의 계층화된 아키텍처를 이해하기 위해 배운 것을 간단히 요약해 보자.   
Docker는 이미지를 빌드할 때 계층화된 아키텍처에서 이미지를 빌드한다.   
```
FROM Ubuntu

RUN apt-get update && apt-get -y install python

RUN pip install flask flask-mysql

COPY . /opt/source-code

ENTRYPOINT FLASK_APP=/opt/source-code/app.py flask run
```
도커 파일의 각 명령 줄은 이전 계층의 변경 사항만으로 도커 이미지에 새 계층을 만든다.   
예를 들어, 첫 번째 계층은 기본 우분투 운영 체제이고, 두 번째 계층은 모든 APT 패키지를 설치하는 두 번째 계층을 만들고, 세 번째 계층은 파이썬 패키지를 사용하는 세 번째 계층을 만든다.   
그 다음에 소스 코드를 복사하는 네 번째 문자가 있고 마지막으로 이미지의 진입점을 업데이트하는 다섯 번째 계층이 있다.   
각 레이어는 이전 레이어의 변경 사항만 저장하기 때문에 크기에도 반영된다.   
기본 우분투 이미지를 보면 크기가 120메가 정도 된다.   

이 계층화된 아키텍처의 이점을 이해하기 위해 두 번째 애플리케이션을 고려해 보겠다.   
```
FROM Ubuntu

RUN apt-get update && apt-get -y install python

RUN pip install flask flask-mysql

COPY app2.py /opt/source-code

ENTRYPOINT FLASK_APP=/opt/source-code/app2.py flask run
```
이 애플리케이션은 다른 도커 파일을 가지고 있지만 우분투와 동일한 기본 이미지를 사용하고 동일한 파이썬 및 플라스크 종속성을 사용하지만 다른 소스 코드를 사용하여 다른 애플리케이션을 생성한다는 점에서 첫 번째 애플리케이션과 매우 유사하다.   
다른 Entry point도 마찬가지이다.   

```
docker build Dockerfile2 -t mmunshad/my-custom-app-2
```
Docker build 명령을 실행하여 이 애플리케이션의 새 이미지를 빌드할 때 두 애플리케이션의 처음 세 계층이 동일하므로 Docker는 처음 세 계층을 빌드하지 않는다.   
<img width="1212" alt="스크린샷 2023-01-20 오후 8 05 51" src="https://user-images.githubusercontent.com/83587720/213680821-3c33584a-4679-4e59-a669-298559c531a6.png">   
대신, 캐시에서 첫 번째 애플리케이션을 위해 구축한 것과 동일한 세 개의 계층을 재사용한다.   
그리고 새 소스와 새 진입점을 사용하여 마지막 두 개의 레이어만 생성한다.   
이러한 방식으로 Docker는 이미지를 더 빨리 빌드하고 디스크 공간을 효율적으로 절약한다.   

이것은 애플리케이션 코드를 업데이트하는 경우에도 적용된다.   
이 경우 app.py와 같은 애플리케이션 코드를 업데이트할 때마다 도커는 캐시에서 이전 계층을 모두 재사용하고 최신 소스 코드를 업데이트하여 애플리케이션 이미지를 빠르게 재구축한다.   
따라서 재구성 및 업데이트 중에 많은 시간을 절약할 수 있다.   

이것을 더 잘 이해할 수 있도록 레이어를 아래로 정렬해 보자.   
<img width="545" alt="스크린샷 2023-01-20 오후 8 07 18" src="https://user-images.githubusercontent.com/83587720/213681092-ae3d8586-6eb6-438f-81b8-356597abc795.png">   

맨 아래에는 기본 Ubuntu 계층, 패키지, 종속성, 애플리케이션의 소스 코드, 그리고 엔트리 포인트가 있다.   
이러한 모든 계층은 최종 도커 이미지를 형성하기 위해 도커 빌드 명령을 실행할 때 생성된다.   
이 모든 것들이 도커 이미지 레이어이다.   
빌드가 완료되면 이러한 레이어의 내용을 수정할 수 없다. 따라서 이 부분들은 모두 읽기 전용이며 새 빌드를 시작해야만 수정할 수 있다.   

docker run 명령을 사용하여 이 이미지를 기반으로 컨테이너를 실행하면 Docker는 이러한 계층을 기반으로 컨테이너를 생성하고 이미지 계층 위에 쓰기 가능한 새 계층을 생성한다.   
```
docker run mmunshad/my-custom-app
```
쓰기 가능 계층은 컨테이너에서 생성된 로그와 같은 임시 파일이나 사용자가 해당 컨테이너에서 수정한 파일만 데이터를 저장하는 데 사용된다.    

그러나 이 레이어의 수명은 컨테이너가 살아있는 동안이다.   
컨테이너가 파괴되면 이 계층과 컨테이너에 저장된 모든 변경사항도 파괴된다.   
동일한 이미지 계층은 이 이미지를 사용하여 생성된 모든 컨테이너에서 공유된다.   

새로 생성된 컨테이너에 로그인하여 temp.txt라는 새 파일을 생성하라고 하면 해당 파일이 컨테이너 계층에 생성되어 읽고 쓸 수 있다.   
이미지 계층의 파일은 읽기 전용이므로 해당 계층의 어떤 것도 편집할 수 없다.   
애플리케이션 코드의 예를 들어 보겠다.   
우리가 우리의 코드를 이미지에 굽기(bake) 때문에 코드는 이미지 레이어의 일부이므로 컨테이너를 실행한 후에만 읽힌다.   

소스 코드를 수정하여 변경 사항을 테스트하려면 어떻게 해야 할까?   
이미지에서 생성된 여러 컨테이너 간에는 동일한 이미지 계층을 공유할 수 있다는 것을 기억하자.    

그럼 컨테이너 안에서 이 파일을 수정할 수 없다는 뜻일까?   
아니다. 이 파일을 수정할 수 있지만 수정된 파일을 저장하기 전에 Docker가 자동으로 읽기 쓰기 계층에 파일의 복사본을 만들고,    
그러면 읽기 쓰기 계층에 있는 다른 버전의 파일을 수정한다.   
이후의 모든 수정은 읽기 쓰기 계층에 있는 파일의 이 복사본에서 수행된다.   
<img width="816" alt="스크린샷 2023-01-20 오후 8 20 45" src="https://user-images.githubusercontent.com/83587720/213683542-a22a9ddb-39ef-4d28-becb-b276318a7a32.png">   

이를 Copy-on-write 메커니즘이라고 한다.   
이미지 계층이 읽기 전용이라는 것은 이러한 계층의 파일이 이미지 자체에서 수정되지 않음을 의미한다.   
따라서 도커 빌드 명령을 사용하여 이미지를 재구성할 때까지 이미지는 항상 동일하게 유지된다.   
컨테이너를 없애면 어떻게 될까? 컨테이너 계층에 저장된 모든 데이터도 삭제된다.   
app.py에 적용한 변경 사항과 새로운 임시 파일도 제거될 것이다.   

이 데이터를 유지하기를 원한다면 어떨까?    
예를 들어, 데이터베이스를 사용할 때 컨테이너에서 생성된 데이터를 보존하려는 경우 Persistence Volume을 컨테이너에 추가할 수 있다.   
이렇게 하려면 먼저 docker volume create 명령을 사용하여 볼륨을 생성한다.   
```
docker volume create data_volumn

#/var/lib/docker/volumes/data_volume
```
docker volume create data_volume 명령을 실행하면 data_volume이라는 폴더가 var/lib/docker/volumes 디렉토리 아래에 생성된다.   
그런 다음 docker run 명령을 사용하여 docker 컨테이너를 실행할 때 -v 옵션을 사용하여    
이 볼륨을 docker 컨테이너 rewrite layer 내부에 마운트할 수 있다.   
```
docker run -v data_volume:/var/lib/mysql mysql
```

Docker run -v를 실행한 다음 새로 생성한 볼륨 이름과 콜론을 작성하고 컨테이너 내 위치를 지정한다.    
이 위치(/lib/mysql)는 SQL이 데이터를 저장하는 기본 위치이며 이미지 이름을 mySQL로 지정한다.   
이렇게 하면 새 컨테이너가 생성되고 우리가 생성한 데이터 볼륨이 컨테이너 내부의 var/lib/mysql 폴더에 마운트된다.   
따라서 데이터베이스에 의해 작성된 모든 데이터는 실제로 Docker 호스트에서 생성된 볼륨에 저장된다.   
컨테이너가 파괴되더라도 데이터는 여전히 활성 상태이다.   

도커 실행 명령 전에 볼륨을 생성하기 위해 도커 볼륨 생성 명령을 실행하지 않았다면 어떻게 될까?    
예를 들어 Docker run 명령을 실행하여 data_volume2로 SQL 컨테이너의 새 인스턴스를 생성하면    
Docker는 자동으로 data_volume2라는 이름의 볼륨을 생성하여 컨테이너에 마운트한다.   
```
docekr run -v data_volume2:/var/lib/mysql mysql
```

var/lib/docker/volumes 폴더의 내용을 나열하면 이러한 볼륨을 모두 볼 수 있다.   
Docker에서 생성한 볼륨을 var/lib/docker/volumes 폴더 아래에 마운트하기 때문에 이를 볼륨 마운트라고 한다.   

데이터가 이미 다른 위치에 있다면 어떨까?    
예를 들어, forward/data의 Docker 호스트에 외부 스토리지가 있고    
데이터베이스 데이터를 기본 var/lib/docker/volumes폴더가 아닌 해당 볼륨에 저장하려고 한다.   
이 경우 docker run -v 명령을 사용하여 컨테이너를 실행하지만 이 경우 마운트할 폴더의 전체 경로를 제공한다.   
```
docker run -v /data/mysql:/var/lib/mysql mysql
```
즉, /data/mysql을 전달하므로 컨테이너를 만들고 폴더를 컨테이너에 마운트한다.   
이를 바인딩 마운트라고 한다.   

마운트에는 두 가지 종류가 있다.   
볼륨 마운팅 및 바인딩 마운트.   

## Volume Mounting
볼륨 마운트는 볼륨 디렉토리에서 볼륨을 마운트하고 바인딩 마운트는 도커 호스트의 모든 위치에서 디렉토리를 마운트한다.   
-v를 사용하는 것은 오래된 스타일이다. 새로운 방법은 -mount option을 사용하는 것이다.   
--mount는 key=value 형식으로 더 상세하게 각각의 매개 변수를 지정해야 하므로 선호되는 방법이다.   
예를 들어, 이전 명령은 대시 마운트 옵션을 사용하여 작성할 수 있다. 이 옵션은 type source 및 target 옵션을 사용하여 작성할 수 있다.   
```
docker run \
--mount type=bind,source=/data/mysql,target=/var/lib/mysql mysql
```
이 경우의 유형은 bind source가 내 호스트의 위치이고 target이 내 위치이다.   

그렇다면 이 모든 작업을 수행하는 책임은 누구에게 있는 것일까?   
계층 구조 유지, 쓰기 가능 계층 생성, 계층 간 파일 이동 등을 통한 복사 및 쓰기 작업들말이다.   
이 책임은 스토리지 드라이버에게 있다.   
따라서 Docker는 스토리지 드라이버를 사용하여 계층화된 아키텍처를 지원한다.   

일반적인 스토리지 드라이버로는 
- AUFS
- ZFS
- BTRFS
- Device Mapper
- Overlay
- Overlay2
가 있다.

스토리지 드라이버의 선택은 사용 중인 기본 OS에 따라 달라진다.   
예를 들어 Ubuntu의 경우 기본 스토리지 드라이버는 AUFS이지만 이 스토어의 드라이버는 Fedora 또는 Cent OS와 같은 다른 운영 체제에서는 사용할 수 없다.   
이 경우 Device Mapper가 더 나은 옵션일 수 있다.   
도커는 운영 체제에 따라 자동으로 사용 가능한 최고의 스토리지 드라이버를 선택한다.   
또한 스토리지 드라이버마다 성능 및 안정성 특성도 다르다.   
따라서 애플리케이션 및 조직의 요구사항에 맞는 것을 선택하여야 할 것이다.   
