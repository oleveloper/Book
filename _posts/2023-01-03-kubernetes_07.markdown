---
layout: post
title: "Kubernetes_07"
date: 2023-01-03
last_modified_at: 2023-01-03
categories: [Kubernetes]
tags: [Kubernetes]
---

# Kube Proxy
쿠버네티스 클러스터에서 모든 pod는 다른 pod에 도달할 수 있다.
이 작업은 pod 네트워킹 솔루션을 클러스터에 배포해 수행된다.
pod 네트워크는 모든 pod가 연결되는 클러스터의 모든 노드에 걸쳐 있는 내부적인 가상 네트워크이다.
이 네트워크를 통해 pod들은 서로 의사소통을 할 수 있는 것이다.
이러한 네트워크를 배포하는 데에 사용할 수 있는 솔루션은 여러 가지가 있다.

첫번째 노드에는 웹 애플리케이션이 배포되고 두번째 노드에는 데이터베이스 애플리케이션이 배포된다고 가정하자.
웹 앱은 단순히 pod의 IP를 사용하여 데이터베이스에 도달할 수 있지만,
데이터베이스 pod의 IP가 항상 동일하게 유지된다는 보장은 없다.

웹 앱이 데이터베이스에 접근하는 더 나은 방법은 서비스를 사용하는 것이다.
따라서 클러스터 전체에 걸쳐 데이터베이스 애플리케이션을 노출하는 서비스를 생성한다.
그러면 이제 웹 앱은 데이터베이스의 서비스 이름을 사용해 데이터베이스에 액세스 할 수 있다.

서비스는 서비스에 할당된 IP 주소 또한 가져온다.
pod는 IP 또는 이름을 사용하여 서비스에 연결하려고 할 때마다 트래픽을 백엔드 pod (이 경우에는 데이터베이스이다.)로 전달한다.

그렇지만 이 서비스는 무엇이며 IP는 어떻게 얻을 수 있는 것일까?
서비스가 동일한 pod 네트워크에 연결된 것일까?
서비스는 실제의 것이 아니기 때문에 서비스는 pod 네트워크에 연결될 수 없다.
서비스는 pod과 같은 컨테이너가 아니기 때문에 인터페이스나 능동적인 listening 프로세스가 없다.
이것은 쿠버네티스 메모리에만 존재하는 가상의 구성 요소이다.

그러나, 모든 노드에서 클러스터를 통해 서비스에 접근할 수 있어야 한다고도 이야기했다.
그것은 어떻게 이루어질까?

여기에서 바로 Kube-proxy가 나오는 것이다.
Kube-proxy는 쿠버네티스 클러스터의 각 노드에서 실행되는 프로세스이다.
새 서비스를 찾는 것이 이 서비스의 역할이며, 새 서비스가 생성될 때 마다 각 노드에서
해당 서비스에 대한 트래픽을 백엔드 pod로 전달하는 적절한 규칙을 생성한다.
이것을 하기 위한 하나의 방법은 iptables 규칙을 사용하는 것이다.
이 경우 클러스터의 각 노드에 iptables 규칙을 생성하여 서비스의 IP로 향하는 트래픽을 실제 pod의 IP로 전달한다. 
이것이 Kube-proxy가 서비스를 구성하는 방법이다.

## Kube-proxy 설치
쿠버네티스 릴리즈 페이지에서 Kube-proxy 바이너리를 다운로드해 압축을 풀고 서비스를 실행한다.
kubeadm은 각 노드에 Kube-proxy를 pod로 배포한다.
이것은 DaemonSet으로 배포되기 때문에 클러스터의 각 노드에 항상 하나의 pod가 배포된다.
