---
layout: post
title: "Kubernetes_67 Pod Networking"
date: 2023-01-24
last_modified_at: 2023-01-24
categories: [Kubernetes]
tags: [Kubernetes]
---

# Pod Networking
지금까지 여러 개의 쿠버네티스 마스터 및 작업자 노드를 설정했고, 이들 노드 간의 네트워킹을 구성하여 모두 서로 연결할 수 있는 네트워크를 만들었다.    
그리고쿠버네티스 control plane이 서로 도달할 수 있도록 방화벽 및 네트워크 보안 그룹이 올바르게 구성되었는지도 확인했다.   
또한 kube-apiserver, etcd 서버, kubelet, 등과 같은 모든 쿠버네티스 control plane components 설정했고 마침내 애플리케이션을 배포할 준비가 되었다고 가정한다.   

하지만 배포하기 전에, 해결해야 할 것이 있다.   
앞서 노드를 연결하는 네트워크에 대해서 이야기했지만, 클러스터가 작동하는 데 중요한 또 다른 네트워킹 계층인 pod 계층의 네트워킹도 존재한다.   
쿠버네티스 클러스터는 많은 수의 pod와 서비스를 실행할 것이다.   
pod는 어떻게 처리될까? pod들은 어떻게 서로 의사소통을 할까? 클러스터 내에서뿐만 아니라 클러스터 외부에서도 이러한 pod에서 실행되는 서비스에 액세스하려면 어떻게 해야 하는걸까?    

오늘날, 쿠버네티스는 이것에 대한 기본 제공 솔루션을 제공하지 않는다.   
쿠버네티스는 유저가 네트워킹 솔루션을 구현하기를 기대하며, pod 네트워킹에 대한 요구 사항을 명확하게 제시한다.   
그것들이 무엇인지 살펴보자.   
쿠버네티스는 모든 pod가 고유한 IP 주소를 가질 것으로 예상한다. 그리고 모든 pod는 해당 IP 주소를 사용하여 동일한 노드 내의 다른 모든 pod에 도달할 수 있어야 한다. 또한 모든 Pod는 동일한 IP 주소를 사용하여 다른 노드의 모든 Pod에 연결할 수 있어야 한다.   
여기서 IP 주소가 어떤 IP 주소이고 어떤 범위 또는 서브넷에 속하는지는 중요하지 않다.   
IP 주소를 자동으로 할당하고 노드의 pod와 다른 노드의 부품 간 연결을 설정하는 솔루션을 구현할 수 있다면 네트워크 규칙을 구성할 필요가 없다.   

그렇다면 이러한 요구사항을 해결하는 모델을 어떻게 구현할 수 있을까?    
이러한 기능을 제공하는 네트워킹 솔루션은 여러 가지가 있지만 네트워킹 개념, 라우팅, IP 주소 관리, 네임스페이스 및 CNI에 대해서는 앞서 이미 이야기했다. 이 지식을 이용해서 먼저 우리 스스로 이 문제를 해결해 보자.   
이를 통해 다른 솔루션의 작동 방식을 이해할 수 있다.   

3개의 노드 클러스터가 있다.   
어느 쪽이 master이고 worker인지는 중요하지 않다.   
관리 또는 워크로드 목적으로 모두 pod를 실행한다.   
네트워킹에 관한 한, 우리는 그것들을 모두 동일하다고 간주할 것이다.   
먼저, 무엇을 할지 계획해 보자.   
<img width="500" alt="스크린샷 2023-01-25 오전 12 50 29" src="https://user-images.githubusercontent.com/83587720/214341269-00d00989-d563-4fd0-848c-9191b2cf786f.png">

노드는 external 네트워크의 일부이며 192.168.1 시리즈에 IP 주소가 있다.   
노드 1은 11, 노드 2는 12, 노드 3은 13이 할당된다.   
다음 단계로, 컨테이너가 생성되면 Kubernetes는 컨테이너에 대한 네트워크 네임스페이스를 생성한다.   
이들 간의 통신을 가능하게 하기 위해, 우리는 이러한 네임스페이스를 네트워크에 연결한다.   
하지만 어떤 네트워크를 말하는 걸까?    

네임스페이스를 연결하기 위해 노드 내에 생성할 수 있는 bridge 네트워크에 대해 배웠다.   
그리고 각 노드에 bridge 네트워크를 만들고 bridge 인터페이스 또는 네트워크에 IP 주소를 할당한다.   

IP 주소는 무엇일까? 우리는 각 bridge 네트워크가 자체 서브넷에 있을 것이라고 결정한다.   
개인 주소 범위(예: 10.244.1, 10.244.1 및 10.244.3)를 선택한다.   
다음으로 브리지 인터페이스의 IP 주소를 설정한다. 그래서 base를 만들었다.   
<img width="932" alt="스크린샷 2023-01-25 오전 12 54 25" src="https://user-images.githubusercontent.com/83587720/214342202-0175adae-6489-463a-a7db-21f5ffde51e6.png">   

나머지 단계는 새 컨테이너가 생성될 때마다 각 컨테이너에 대해 수행된다.   
그래서 우리는 그것을 위한 스크립트를 작성한다. 이제 복잡한 스크립팅을 알 필요가 없다.   
이 파일은 앞으로 사용할 모든 명령이 포함된 파일이며, 앞으로 각 컨테이너에 대해 여러 번 실행할 수 있다.   

컨테이너를 네트워크에 연결하려면 파이프 또는 가상 네트워크 케이블이 필요하다.   
이는 ip link add 명령을 사용하여 생성한다.   
다음 ip link set 명령을 사용하여 한쪽 끝을 컨테이너에 부착하고 다른 쪽 끝을 bridge에 붙인다.   
이후 ip addr 명령을 사용하여 IP 주소를 할당하고 기본 게이트웨이에 경로를 추가한다.   

하지만 어떤 IP를 추가해야 할까? 우리는 그 정보를 스스로 관리하거나 일종의 데이터베이스에 저장한다.   
현재로서는 서브넷에서 사용 가능한 IP인 10.244.1.2라고 가정한다.   

마지막으로, 인터페이스를 불러온다.   
그런 다음 두 번째 컨테이너에 대해 동일한 스크립트를 실행하고 해당 컨테이너를 네트워크에 연결한다.   
이제 두 컨테이너가 서로 통신할 수 있다.   
스크립트를 다른 노드에 복사하고 스크립트를 실행하여 IP 주소를 할당하고 해당 컨테이너를 자체 내부 네트워크에 연결한다.   
그러면 이제 pod들은 모두 고유한 IP 주소를 얻으며, 각자의 노드에서 서로 통신할 수 있다.   

다음 부분은 다른 노드의 다른 pod에 도달할 수 있도록 하는 것이다.   
예를 들어 10.244.1.2에 있는 Pod(노드 1)가 Pod 10.244.2.2 또는 노드 2를 ping하려고 한다고 가정한다.   
현재 첫 번째 주소는 주소 10.244.2.2가 자신의 네트워크와 다른 네트워크에 있기 때문에 주소가 어디에 있는지 알지 못한다.   
따라서 기본 게이트웨이로 설정된 노드의 IP로 라우팅된다.   
10.244.2.2는 노드 2의 전용 네트워크이므로 노드 1도 알 수 없다.   
노드 1의 라우팅 테이블에 경로를 추가하여 트래픽을 10.244.2.2로 라우팅한다.    
여기서 두 번째 노드의 IP는 192.168.1.12이다.   
경로가 추가되면 파란색 pod가 핑을 통과할 수 있다.   

마찬가지로, 내부의 각 네트워크에 대한 정보를 사용하여 모든 호스트에서 다른 모든 호스트로의 경로를 구성한다.   
이 간단한 설정에서는 잘 작동하지만 기본 네트워크 아키텍처가 복잡해질 때는 훨씬 더 많은 구성이 필요하다.   
각 서버에서 경로를 구성할 필요가 없는 대신 네트워크에 라우터가 있는 경우 라우터에서 경로를 구성하고 모든 호스트가 이를 기본 게이트웨이로 사용하도록 지정하는 것이 더 나은 솔루션이다.   
이렇게 하면 라우터의 라우팅 테이블에 있는 모든 네트워크에 대한 경로를 쉽게 관리할 수 있다.   
이를 통해 각 노드에서 주소가 10.244.1.0/24인 개별 가상 네트워크가 이제 주소가 10.244.0.0/16인 단일 대규모 네트워크를 형성한다.   
이제 모든 것을 한데 묶어야 할 때이다.   
브리지 네트워크와 라우팅 테이블을 사용하여 환경을 준비하기 위해 여러 가지 수동 단계를 수행했다.   
각 컨테이너를 네트워크에 연결하는 데 필요한 단계를 수행하는 각 컨테이너에 대해 실행할 수 있는 스크립트를 작성하고 스크립트를 수동으로 실행했다.   

그렇다면 쿠버네티스에서 pod가 생성될 때 어떻게 자동으로 스크립트를 실행할 수 있을까?    
여기에서 바로 중간자 역할을 하는 CNI가 나온다.   
CNI는 컨테이너를 생성하는 즉시 스크립트를 호출하는 방법을 Kubernetes에 알려준다.   
<img width="436" alt="스크린샷 2023-01-25 오전 1 04 53" src="https://user-images.githubusercontent.com/83587720/214344906-125fad29-6899-4b10-b843-06bc6e1fe20a.png">   

CNI는 우리에게 스크립트가 이렇게 보여야 한다고 말한다.   
<img width="436" alt="스크린샷 2023-01-25 오전 1 05 25" src="https://user-images.githubusercontent.com/83587720/214345024-d7474f7e-e1d8-4025-a2c8-6f7800e0caef.png">   

그래서 우리는 CNI 기준에 맞게 스크립트를 조금 수정해야 한다.   
네트워크에 컨테이너를 추가하는 추가 섹션과 네트워크에서 컨테이너 인터페이스를 삭제하는 삭제 섹션이 있어야 한다.   
