---
layout: post
title: "Kubernetes_65 Prerequisite - CNI"
date: 2023-01-24
last_modified_at: 2023-01-24
categories: [Kubernetes]
tags: [Kubernetes]
---

# Prerequisite - CNI

컨테이너 네트워킹 인터페이스에 대해 알아보자.   
지금까지 네트워크 네임스페이스가 작동하는 방법들로 아래와 같은 내용들을 살펴보았다.   
- 시스템 내에서 격리된 네트워크 네임스페이스 환경을 만드는 방법   
- 브리지 네트워크를 통해 이러한 여러 네임스페이스를 연결하는 방법   
- 양쪽 끝에 가상 인터페이스가 있는 가상 케이블 또는 파이프를 만드는 방법   
- 각 엔드 투 엔드 네임스페이스와 브리지를 연결하는 방법   
- IP 할당/불러오기   
- 외부 통신을 위해 NAT 또는 IP masquerade 활성화 하는 방법   

그런 다음 Docker가 Bridge Networking options을 어떻게 수행하는지 확인했다.   
그것은 다른 네이밍 패턴을 사용한다는 것을 제외하고는 네트워크 네임스페이스와 거의 같은 방식이었다.   
<img width="1087" alt="스크린샷 2023-01-24 오후 8 50 04" src="https://user-images.githubusercontent.com/83587720/214284329-d42baae5-3a9a-4c9a-9d6b-1eb9efcdd2b6.png">   
다른 컨테이너 솔루션들도 같은 방식으로 네트워킹 문제를 해결한다.    
Rocket이나 Mesos Container와 같이 컨테이너와 함께 작동하고 쿠버네티스와 같이 컨테이너 간의 네트워킹을 구성해야 하는 다른 솔루션들도 마찬가지이다.   
모두가 사소한 차이를 가지고 유사한 접근 방식을 연구하고 최종적으로 식별함으로써 동일한 네트워킹 문제를 해결하려고 한다면, 왜 동일한 솔루션을 여러 번 코딩하고 개발하는가? 모두가 따를 수 있는 단일 표준 접근 방식을 만들어 보는 것은 어떨까?    
그래서 쿠버네티스는 이 모든 아이디어를 다른 솔루션에서 가져와 그것의 모든 네트워킹 부분을 하나의 프로그램 또는 코드로 옮겼다.   

이것은 Bridge 네트워크를 위한 것이기 때문에, 우리는 그것을 Bridge라고 부른다.   
컨테이너를 Bridge 네트워크에 연결하기 위해 필요한 모든 작업을 수행하는 프로그램이나 스크립트를 만들었다.   
예를 들어 Bridge라는 이름을 사용하여 이 프로그램을 실행하고 특정 네트워크 이름 공간에 이 컨테이너를 추가하도록 지정할 수 있다.   
```
bridge add 2e34dcf34 /var/run/netns/2e34dcf34
```

Bridge 프로그램은 컨테이너 런타임 환경이 이러한 작업에서 벗어나도록 나머지 부분을 처리한다.   
예를 들어, Rocket 또는 쿠버네티스가 새 컨테이너를 만들 때 Bridge Program을 호출하고 컨테이너 ID와 네임스페이스를 전달하여 해당 컨테이너에 대한 네트워킹을 구성한다.   
```
bridge add <cid> <namespace>
```

만약 새로운 네트워킹 유형을 위해 그런 프로그램을 만들고 싶다면 어떨까?    
프로그램은 어떤 인수와 명령을 지원해야 할까? 작성한 프로그램이 현재 런타임에 맞게 작동하는지 어떻게 확인할 수 있을까? 쿠버네티스 또는 Rocket과 같은 컨테이너 런타임이 프로그램을 호출하는지 어떻게 알 수 있을까?    
이것들이 우리가 정의해야 할 몇 가지 기준이 필요한 부분이다.   
프로그램이 어떻게 보여야 하는지 컨테이너 런타임이 어떻게 실행되는지 정의하는 표준을 통해 모든 사용자가 standard single set를 준수하고 런타임에 걸쳐 작동하는 솔루션을 개발할 수 있다.   

여기서 컨테이너 네트워크 인터페이스가 등장한다.   
Kubernetes나 Rocket과 같은 컨테이너 런타임이 당신의 프로그램을 정확하게 호출할 것이라는 것을 어떻게 알까? 그것이 정의해야 할 몇 가지 기준이 필요한 부분이다.   
CNI는 컨테이너 런타임 환경에서 네트워킹 문제를 해결하기 위해 프로그램을 개발하는 방법을 정의하는 standard의 집합이다.   

프로그램을 플러그인이라고 한다.   
이 경우, 우리가 언급했던 Bridge 프로그램은 CNI의 플러그인이다.   
CNI는 플러그인을 개발하는 방법과 컨테이너 런타임이 플러그인을 호출하는 방법을 정의한다.   
CNI는 컨테이너 런타임 및 플러그인에 대한 일련의 responsibilities를 정의한다.   
컨테이너 런타임의 경우, CNI는 각 컨테이너에 대한 네트워크 이름 공간을 생성하도록 지정한다.   
그런 다음 컨테이너가 연결되어야 하는 네트워크를 식별해야 한다.    
컨테이너 런타임은 add 명령을 사용하여 컨테이너를 생성할 때 플러그인을 호출해야 하며, del 명령을 사용하여 컨테이너를 삭제할 때 플러그인을 호출해야 한다.   
또한 JSON 파일을 사용하여 컨테이너 런타임 환경에서 네트워크 플러그인을 구성하는 방법도 지정한다.   
플러그인 측에서는 플러그인이 add, del 및 check 명령줄 인수를 지원해야 하며 컨테이너 및 네트워크 네임스페이스와 같은 매개 변수를 허용해야 한다고 정의한다.   
플러그인은 컨테이너가 네트워크의 다른 컨테이너에 도달하는 데 필요한 팟 및 관련 경로에 IP 주소를 할당해야 한다.   

마지막에 결과를 특정 형식으로 지정해야 한다.   
컨테이너 가동 시간과 플러그인이 이러한 표준을 준수하는 한, 그들은 모두 함께 조화롭게 있을 수 있다.   
모든 런타임은 모든 플러그인을 사용하여 작업할 수 있어야 한다.   
CNI에는 Bridge, VLAN, IP VLAN, MAC VLAN, 윈도우즈용 플러그인 및 Host Local 및 DHCP와 같은 IPAM 플러그인과 같은 이미 지원되는 플러그인 집합이 함께 제공된다.   
타사 조직에서 사용할 수 있는 다른 플러그인도 있다.   
예를 들어 Weave, Flannel, Cilium, VMware NSX, Calico, Infoblox 등이 있다.   
이러한 모든 컨테이너 런타임은 CNI 표준을 구현하므로 이러한 플러그인 중 하나라도 작동할 수 있다.   
하지만 이 목록에 없는 것이 하나 있다.   

바로 도커이다.   
도커는 CNI를 구현하지 않는다.   
도커는 CNM이라는 자체 표준을 가지고 있는데, 컨테이너 네트워킹 문제를 해결하는 것을 목표로 하는 또 다른 표준인 컨테이너 네트워크 모델을 의미한다. (CNI와 유사하지만 약간의 차이가 있다.)   
이러한 차이점 때문에 이러한 플러그인은 기본적으로 도커와 통합되지 않는다.    
즉, 도커 컨테이너를 실행하고 네트워크 플러그인을 지정하여 CNI를 사용할 수 없으며 이러한 플러그인 중 하나를 지정할 수 없다는 것이다.   
그렇다고 해서 도커를 CNI와 함께 사용할 수 없는 것은 아니다. 이를 위해서는 유저가 직접 해결해야 한다.   
아래와 같이 네트워크 구성 없이 Docker 컨테이너를 생성한 다음 bridge 플러그인을 직접 수동으로 호출한다.   
```
docker run --network=none nginx
bridge add 2e34dcf34 /var/run/netns/2e34dcf34
```
그것이 Kubernetes가 그것을 하는 거의 방법이다.   
Kubernetes는 Docker 컨테이너를 만들 때 네트워크가 아닌 곳에 컨테이너를 만든다.   
그 다음 component의 나머지 부분을 처리하는 구성된 CNI 플러그인을 호출한다.   
