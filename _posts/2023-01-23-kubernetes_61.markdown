---
layout: post
title: "Kubernetes_61 Prerequisite - Switching Routing"
date: 2023-01-23
last_modified_at: 2023-01-23
categories: [Kubernetes]
tags: [Kubernetes]
---

# Switching

스위칭, 라우팅, 게이트웨이 등과 같은 기본적인 네트워킹 개념을 살펴보고, 그 다음 DNS를 이해하고 CoreDNS에 대한 기본적인 소개를 하도록 하겠다.   
우선 Linux 시스템에서 DNS 설정을 구성하는 방법에 대해 알아보고 Linux에서 네트워크 네임스페이스의 기본 사항을 이해해보자.   

그렇다면 네트워크란 무엇일까?    
두 대의 컴퓨터 A와 B가 있다고 하자. 노트북, 데스크톱, 클라우드 상의 VM, 어디든, 시스템 A는 B에 어떻게 도달할 수 있을까?   
<img width="886" alt="스크린샷 2023-01-23 오후 11 36 43" src="https://user-images.githubusercontent.com/83587720/214066377-08f97e97-6dff-4054-b46d-bb47dc750830.png">   
A, B를 스위치에 연결하고 스위치는 두 시스템을 포함하는 네트워크를 만든다.   
스위치에 연결하려면 각 호스트에 물리적 또는 가상의 호스트 별 인터페이스가 필요하다.   
호스트의 인터페이스를 확인하려면 ip link 명령을 사용한다.   
```
ip link
```
스위치에 연결하는 데 사용할 eth0이라는 인터페이스를 보자.   
주소가 192.168.1.0인 네트워크라고 가정한다.   
그런 다음 동일한 네트워크에 IP 주소를 가진 시스템을 할당한다.   
이를 위해 ip addr 명령을 사용한다.   
```
ip addr add 192.168.1.10/24 dev eth0

ip addr add 192.168.1.11/24 dev eth0
```
link가 작동하고 IP 주소가 할당되면 컴퓨터는 이제 스위치를 통해 서로 통신할 수 있다.   

스위치는 네트워크 내에서만 통신을 활성화할 수 있다.    
즉, 네트워크의 호스트로부터 패킷을 수신하면 동일한 네트워크 내에서 다른 시스템으로 전송할 수 있다.   
주소 192.168.2.0에 시스템 C와 D가 있는 다른 네트워크가 있다고 가정해 보자.   
시스템의 IP 주소는 각각 192.168.2.10 및 2.11이다.   
<img width="1102" alt="스크린샷 2023-01-23 오후 11 42 41" src="https://user-images.githubusercontent.com/83587720/214067880-05358f27-2f3e-49d7-8a43-c0ad8c22ebc7.png">   
한 네트워크의 시스템이 다른 네트워크의 시스템에 어떻게 도달할 수 있을까?    
IP가 192.168.1.11인 시스템 B는 다른 네트워크의 IP가 2.10인 시스템 C에 어떻게 도달할까? 여기에서 라우터가 등장한다.   
<img width="1110" alt="스크린샷 2023-01-23 오후 11 44 09" src="https://user-images.githubusercontent.com/83587720/214068204-2965592a-827a-4fdd-88ae-7930aeb72762.png">   

라우터는 두 개의 네트워크를 함께 연결하는 것을 도와준다.   
라우터는 지능적인 device이다.   
라우터를 네트워크 포트가 많은 또 다른 서버라고 생각해 보자.   
이 서버(라우터)는 두 개의 개별 네트워크에 연결되기 때문에 각 네트워크에 하나씩 두 개의 IP가 할당된다.   
첫 번째 네트워크에는 IP 주소 192.168.1.1을 할당한다.   
두 번째 네트워크에는 IP 2.1을 할당한다.   
이제, 우리는 그들 사이의 통신을 가능하게 할 수 있는 두 개의 네트워크에 연결된 라우터를 가지고 있다.   
시스템 B가 시스템 C로 패킷을 보내려고 할 때, 어떻게 라우터가 패킷을 보낼 네트워크의 어디에 있는지 알 수 있을까? 
라우터는 네트워크의 다른 장치일 뿐이다. 다른 많은 장치들이 있을 수 있다.   
여기서 게이트웨이 또는 Route로 시스템을 구성할 수 있다.   
네트워크가 방이라면, 게이트웨이는 다른 네트워크 또는 인터넷으로 연결되는 외부 세계의 문이다.   
시스템은 그것을 통과하기 위해 저 문이 어디에 있는지 알아야 한다.   

시스템의 기존 라우팅 구성을 보려면 route 명령을 실행한다.   
```
route
```   
이 명령은 커널의 라우팅 테이블을 표시한다.   
명령을 입력했을 때 라우팅 구성이 없다면 시스템 B는 시스템 C에 도달할 수 없다.   
192.168.1.0 범위의 동일한 네트워크 내의 다른 시스템에만 연결할 수 있다.   

시스템 B의 게이트웨이가 네트워크 2.0의 시스템에 연결되도록 구성하려면 ip route add 명령을 실행하고 192.168.1.1.1의 문 또는 게이트웨이를 통해 192.168.2.0 네트워크에 연결할 수 있도록 지정한다.   
```
ip route add 192.168.2.0/24 via 192.168.1.1
```
route 명령을 다시 실행하면 라우터를 통해 192.168.2.0 시리즈 네트워크에 도달하기 위해 경로가 추가되었음을 알 수 있다.   

모든 시스템에서 이 기능을 구성해야 한다.   
예를 들어, 시스템 C가 시스템 B로 패킷을 전송하려면 시스템 C의 라우팅 테이블에 경로를 추가하여 IP 주소 2.1로 구성된 라우터를 통해 1.0에 있는 네트워크에 액세스해야 한다.   
```
ip route add 192.168.1.0/24 via 192.168.2.1
```

이제, 이 시스템들이 인터넷에 접속할 필요가 있다고 가정해보자.   
인터넷에서 172.217.194.0 네트워크로 구글에 접속해야 한다고 하자.   
따라서 라우터를 인터넷에 연결한 다음 라우팅 테이블에 새 경로를 추가하여 라우터를 통해 모든 트래픽을 네트워크 172.217.194로 라우팅한다.   
```
ip route add 172.217.194.0/24 via 192.168.2.1
```

인터넷에는 서로 다른 네트워크에 있는 매우 많은 다양한 사이트들이 있다.   
각 네트워크에 대해 동일한 라우터의 IP 주소에 대한 라우팅 테이블 항목을 추가하는 대신, route를 모르는 네트워크에 대해 이 라우터를 기본 게이트웨이로 사용할 수 있다.   
```
ip route add default via 192.168.2.1
```
이렇게 하면 기존 네트워크 외부의 네트워크에 대한 모든 요청이 이 특정 라우터로 전송된다.   
이러한 간단한 설정에서는 기본 게이트웨이가 라우터의 IP 주소로 설정된 단일 라우팅 테이블 항목만 있으면 된다.   
default라는 단어 대신 0.0.0.0이라고 말할 수도 있다.   
이는 모든 IP 대상을 의미하며 모두 같은 의미이다.   
게이트웨이 필드에 0.0.0.0 항목이 있으면 게이트웨이가 필요하지 않음을 나타낸다.   
<img width="500" alt="스크린샷 2023-01-23 오후 11 58 19" src="https://user-images.githubusercontent.com/83587720/214071796-8123e03a-c9ae-4c72-9c1a-744c746fe384.png">   
예를 들어, 이 경우 시스템 C는 192.168.2.0의 모든 장치에 액세스할 수 있다.   
이 네트워크는 자체 네트워크에 있기 때문에 게이트웨이가 필요하지 않다.   

그러나 네트워크에 라우터가 여러 개 있다고 가정해 보자.   
하나는 인터넷용이고 다른 하나는 내부 사설망용이다.   
그러므로 각 네트워크에 대해 두 개의 개별 항목이 있어야 한다.   
내부 전용 네트워크에 대한 항목 하나, 공용 네트워크를 포함한 다른 모든 네트워크에 대한 기본 게이트웨이가 있는 항목 하나이다.   
따라서 시스템에서 인터넷에 연결하는 데 문제가 있는 경우 이 라우팅 테이블과 기본 게이트웨이 구성을 시작하는 것이 좋다.   

이제 Linux 호스트를 라우터로 설정하는 방법을 살펴보자.   
간단한 설정부터 시작하겠다.   
A, B, C 세 호스트가 있다고 가정한다.   
A와 B는 네트워크 192.168.1에 연결되고 B와 C는 192.168.2에 연결된다.   
호스트 B는 eth0과 eth1이라는 두 개의 인터페이스를 사용하여 두 네트워크에 모두 연결된다.   
A의 IP는 192.168.1.5이다.   
C에는 192.168.2.5가 있다.   
그리고 B는 네트워크 1.6과 2.6 모두에 IP를 가지고 있다.   
<img width="1081" alt="스크린샷 2023-01-24 오전 12 01 19" src="https://user-images.githubusercontent.com/83587720/214072545-2d942bb3-5cb6-4fce-81b4-447896ba9f71.png">   
이 상황에서 어떻게 A와 C가 연결되도록 할 수 있을까?    
기본적으로 A에서 2.5로 ping을 시도하면 네트워크에 연결할 수 없다고 표시된다.   
호스트 A는 192.168.2에 있는 네트워크에 연결하는 방법을 알지 못하기 때문이다.   
우리는 호스트 A에게 네트워크 2의 문 또는 게이트웨이가 호스트 B를 통과한다고 말해야 한다.   
라우팅 테이블 항목을 추가하여 이 작업을 수행한다.   
```
ip route add 192.168.0.2/24 via 192.168.1.6
```
게이트웨이 192.168.1.6을 통해 네트워크 192.168.2에 액세스하는 경로를 추가한다.
패킷이 호스트 C에 전달될 경우 호스트 C는 호스트 A에 응답을 다시 전송해야 한다.
호스트 C가 192.168.1 네트워크의 호스트 A에 연결하려고 하면 동일한 문제가 발생한다.
그래서 우리는 호스트 C가 라우터 역할을 하는 호스트 B를 통해 호스트 A에 도달할 수 있다는 것을 알려야 한다.
그래서 우리는 호스트 C의 라우팅 테이블에 유사한 항목을 추가한다.
```
ip route add 192.168.1.0/24 via 192.168.2.6
```
이번에는 네트워크 192.168.1.0에 연결하려면 호스트 B(192.168.2.6)와 대화해야 한다.   
지금 ping을 시도하면 더 이상 네트워크에 연결할 수 없는 오류 메시지가 표시되지 않는다.   
그것은 라우팅 항목이 올바르게 설정되었다는 것을 의미한다.   

하지만 여전히 ping을 시도했을 때 아무런 응답을 받지 못하고 있다.   
기본적으로 리눅스에서 패킷은 한 인터페이스에서 다음 인터페이스로 전달되지 않는다.   
예를 들어 호스트 B의 eth0에서 수신된 패킷은 eth1을 통해 다른 곳으로 전달되지 않는다.   
보안상의 이유로 이 방법을 사용한다.   
예를 들어 eth0을 개인 네트워크에 연결하고 eth1을 공용 네트워크에 연결한 경우, 사용자가 명시적으로 허용하지 않는 한 공용 네트워크의 다른 사용자가 개인 네트워크에 메시지를 쉽게 보내지 않도록 한다.   
그러나 이 경우 둘 다 개인 네트워크이고 둘 사이의 통신을 가능하게 하는 것이 안전하다는 것을 알기 때문에 호스트 B가 한 네트워크에서 다른 네트워크로 패킷을 전달하도록 허용할 수 있다.   

호스트가 인터페이스 간에 패킷을 전달할 수 있는지 여부는  /proc/system/net/ipv4/ip_forward 파일의 시스템 설정에 따라 결정된다.   
기본적으로 이 파일의 값은 0으로 설정되어 전달되지 않음을 의미한다.   
```
cat /proc/system/net/ipv4/ip_forward
```
이것을 1로 설정하면 ping이 진행되는 것을 볼 수 있다.   
```
echo 1 > /proc/system/net/ipv4/ip_forward
```
이 값만 설정한다면 재부팅 후에는 변경 내용이 유지되지 않는다.   
그러기 위해서는 etc/sysctl.conf에서 동일한 값을 수정해야 한다.   
```
net.ipv4.ip_forward = 1
```

몇 가지 핵심 명령을 보겠다.   
ip link는 호스트의 modify 인터페이스를 나열한다.   
ip addr 명령은 이러한 인터페이스에 할당된 IP 주소를 확인하는 명령어이다.   
ip addr add 명령은 인터페이스의 IP 주소를 설정하는 데 사용된다.   
```
ip addr add 192.168.1.10/24 dev eth0
```
이러한 명령을 사용하여 변경한 내용은 다시 시작할 때까지만 유효한다.   
변경 내용을 유지하려면 etc/network/interfaces 파일에서 변경 내용을 설정해야 한다.   
ip route 또는 단순히 route 명령을 사용하여 라우팅 테이블을 본다.   
그리고 ip route add 명령은 라우팅 테이블에 항목을 추가하는 데 사용된다.   
```
ip route add 192.168.1.0/24 via 192.168.2.1
```
마지막으로 라우터로 구성된 호스트의 경우, 호스트에서 IP forwarding 여부를 확인하는 명령을 기억하도록 하자.   
```
cat /proc/system/net/ipv4/ip_forward
```
